/**
 * Teaching Plan Transformer
 * Business logic for transforming teaching plan data
 * Normalizes different plan formats and structures
 */

import type {
  TeachingPlan,
  GeneratedTeachingPlan,
  TeachingPlanWorkProposal,
} from '@/types'

/**
 * Week Schedule format for display
 */
export interface WeekSchedule {
  id: string
  week: number
  startDate: string
  endDate: string
  content: string
  methodology: string
  hours: number
}

/**
 * Normalize work proposal from different formats to WeekSchedule
 * Handles both scraped plans and AI-generated plans
 *
 * @param propostaTrabalho - Work proposal from teaching plan
 * @returns Array of week schedules
 */
export function normalizeWorkProposalToWeekSchedule(
  propostaTrabalho: TeachingPlanWorkProposal[] | any[]
): WeekSchedule[] {
  if (!propostaTrabalho || propostaTrabalho.length === 0) {
    return []
  }

  return propostaTrabalho.map((item, index) => {
    // Handle scraped format
    if ('mes' in item && 'periodo' in item) {
      return {
        id: `week-${index + 1}`,
        week: index + 1,
        startDate: item.periodo || '',
        endDate: item.periodo || '',
        content: item.conteudo || '',
        methodology: item.metodologia || '',
        hours: parseInt(item.numAulas || '0', 10),
      }
    }

    // Handle AI-generated format
    if ('semana' in item) {
      return {
        id: `week-${item.semana}`,
        week: item.semana,
        startDate: item.dataInicio || '',
        endDate: item.dataFim || '',
        content: item.conteudo || '',
        methodology: item.metodologia || '',
        hours: item.horasTotais || 0,
      }
    }

    // Fallback for unknown format
    return {
      id: `week-${index + 1}`,
      week: index + 1,
      startDate: '',
      endDate: '',
      content: String(item.conteudo || item.content || ''),
      methodology: String(item.metodologia || item.methodology || ''),
      hours: parseInt(String(item.numAulas || item.hours || '0'), 10),
    }
  })
}

/**
 * Merge generated plan with existing plan data
 * Combines AI-generated content with scraped system data
 *
 * @param generatedPlan - Plan generated by AI
 * @param existingPlan - Existing plan from system
 * @returns Merged teaching plan
 */
export function mergeGeneratedWithExistingPlan(
  generatedPlan: GeneratedTeachingPlan,
  existingPlan?: Partial<TeachingPlan>
): Partial<TeachingPlan> {
  return {
    ...existingPlan,
    objetivoGeral: generatedPlan.objetivoGeral,
    objetivosEspecificos: generatedPlan.objetivosEspecificos,
    avaliacaoAprendizagem: generatedPlan.avaliacaoAprendizagem,
    recuperacaoAprendizagem: generatedPlan.recuperacaoAprendizagem,
    propostaTrabalho: generatedPlan.propostaTrabalho,
    // Keep system fields from existing plan
    ementa: existingPlan?.ementa,
    referencias: existingPlan?.referencias,
    cargaHorariaTotal: existingPlan?.cargaHorariaTotal,
  }
}

/**
 * Calculate total hours from work proposal
 * @param workProposal - Work proposal array
 * @returns Total hours
 */
export function calculateTotalHoursFromProposal(
  workProposal: TeachingPlanWorkProposal[] | any[]
): number {
  if (!workProposal || workProposal.length === 0) {
    return 0
  }

  return workProposal.reduce((total, item) => {
    const hours =
      parseInt(item.numAulas || item.horasTotais || item.hours || '0', 10)
    return total + (isNaN(hours) ? 0 : hours)
  }, 0)
}

/**
 * Validate teaching plan data
 * @param plan - Teaching plan to validate
 * @returns Validation result
 */
export function validateTeachingPlan(plan: Partial<TeachingPlan>): {
  isValid: boolean
  errors: string[]
} {
  const errors: string[] = []

  if (!plan.objetivoGeral || plan.objetivoGeral.trim() === '') {
    errors.push('Objetivo geral é obrigatório')
  }

  if (!plan.objetivosEspecificos || plan.objetivosEspecificos.trim() === '') {
    errors.push('Objetivos específicos são obrigatórios')
  }

  if (!plan.avaliacaoAprendizagem || plan.avaliacaoAprendizagem.length === 0) {
    errors.push('Avaliação de aprendizagem é obrigatória')
  }

  if (!plan.propostaTrabalho || plan.propostaTrabalho.length === 0) {
    errors.push('Proposta de trabalho é obrigatória')
  }

  return {
    isValid: errors.length === 0,
    errors,
  }
}

/**
 * Format evaluation assessment for display
 * @param evaluations - Array of evaluations
 * @returns Formatted string
 */
export function formatEvaluationAssessment(
  evaluations: TeachingPlan['avaliacaoAprendizagem']
): string {
  if (!evaluations || evaluations.length === 0) {
    return 'Nenhuma avaliação definida'
  }

  return evaluations
    .map((evaluation, index) => {
      return `${index + 1}. ${evaluation.avaliacao} - ${evaluation.instrumentos} (${evaluation.valorMaximo}pts)`
    })
    .join('\n')
}

/**
 * Extract text content from teaching plan for search/indexing
 * @param plan - Teaching plan
 * @returns Searchable text content
 */
export function extractSearchableContent(plan: TeachingPlan): string {
  const parts = [
    plan.curso,
    plan.unidadeCurricular,
    plan.ementa,
    plan.objetivoGeral,
    plan.objetivosEspecificos,
    plan.referencias,
  ]

  return parts.filter(Boolean).join(' ').toLowerCase()
}

/**
 * Check if teaching plan is complete
 * @param plan - Teaching plan
 * @returns True if all required fields are filled
 */
export function isTeachingPlanComplete(plan: Partial<TeachingPlan>): boolean {
  const requiredFields = [
    plan.objetivoGeral,
    plan.objetivosEspecificos,
    plan.avaliacaoAprendizagem && plan.avaliacaoAprendizagem.length > 0,
    plan.propostaTrabalho && plan.propostaTrabalho.length > 0,
    plan.referencias,
  ]

  return requiredFields.every(Boolean)
}
